/*
 * Copyright 2013, The Thymeleaf Project (http://www.thymeleaf.org/)
 *
 * Licenciado bajo la Licencia Apache, Versión 2.0 (la "Licencia");
 * No puede usar este archivo excepto de conformidad con la Licencia.
 * Puede obtener una copia de la Licencia en
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Salvo que lo exija la legislación aplicable o se acuerde por escrito, el software
 * distribuido bajo la Licencia se distribuye "TAL CUAL",
 * SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
 * Consulte la Licencia para conocer el idioma específico que rige los permisos y las
 * limitaciones de la Licencia.
 */

import com.github.psxpaul.task.ExecFork
import org.apache.tools.ant.filters.ReplaceTokens

import java.time.LocalDate
import java.time.format.DateTimeFormatter
import java.time.temporal.TemporalAccessor

/**
 * El script de compilación de Gradle para el proyecto Thymeleaf Docs convierte
 * los archivos de documentación, en formato Markdown, a formatos HTML y PDF.
 * 
 * @author Emanuel Rabina
 */

plugins {
	id 'java'
	id 'war'
	id 'com.github.psxpaul.execfork' version '0.2.2'
	id 'org.gretty' version '4.0.3'
}

repositories {
	mavenCentral()
	maven {
		url 'https://plugins.gradle.org/m2/'
	}
}

gretty {
	scanInterval 0
}

// Reemplaza los marcadores de posición @projectVersion@ y @documentVersion@ en los documentos
def documentMetadata = [
  '2.1': [
	  version: '2.1.6.RELEASE',
	  date: LocalDate.of(2017, 11, 5)
  ],
	'3.0': [
	  version: '3.0.11.RELEASE',
		date: LocalDate.of(2018, 10, 29)
	],
	'3.1': [
	  version: '3.1.3.RELEASE',
		date: LocalDate.of(2024, 12, 9)
	]
]

def conversions = [
	articles: ['html'],
	tutorials: ['html', 'ebook', 'pdf']
]
def docsDir      = file("${projectDir}/docs")
def imagesDir    = file("${projectDir}/images")
def scriptsDir   = file("${projectDir}/scripts")
def stylesDir    = file("${projectDir}/styles")
def templatesDir = file("${projectDir}/templates")
def srcDir       = file("${buildDir}/source")
def outputDir    = file("${buildDir}/site/doc")

project.webAppDirName = outputDir

def docNames = [] as Set
def docTypes = [:]

/**
 * Copia todos los documentos y recursos al directorio de origen, desde donde
 * se enviarán a pandoc. Además, durante esta operación de copia, los archivos
 * Markdown se filtrarán para que las propiedades de Gradle se resuelvan en sus
 * secciones de metadatos.
 *
 * Tenga en cuenta que, para los archivos .doc, el nombre de la carpeta en la
 * que se encuentran se considerará su "tipo de documento", lo que influirá en
 * el tipo de conversiones que se les aplicarán.
 */
tasks.register('copyResources') {
	doLast {

		// Copia los archivos docs a la carpeta src. Para los archivos Markdown, aplica el filtro de propiedades y crea el mapa de nombre-tipo.
		copy {
			from docsDir
			into srcDir

			filesMatching('**/*.md') {

				// Necesitamos una ruta de archivo relativa a la carpeta 'docs'
				def docFileName = (it.relativePath.toString() - ".md").replace('\\', '/')
				def docFileType = it.file.parentFile.name
				def thymeleafVersion = null

				// En algunos casos, la carpeta principal puede ser un número de versión (p. ej., tutoriales para 2.1, 3.0, etc.). En
				// tal caso, necesitamos obtener el tipo de documento de la carpeta principal. Tenga en cuenta
				// que se permiten tres tipos de especificaciones de versión: '2.1', '2.1.4', '2.1.x'.
				if (docFileType ==~ /\d+\.\d+(\.\d+)?/ || docFileType ==~ /\d+\.\d+(\.x)?/) {
					thymeleafVersion = it.file.parentFile.name
					docFileType = it.file.parentFile.parentFile.name
				}

				docNames.add(docFileName)
				docTypes.put(docFileName, docFileType)

				// Filtrado de propiedades, esto reemplazará todas las @gradle-properties@ (principalmente utilizadas en metadatos de Markdown)
				var documentMetadataForVersion = documentMetadata[(thymeleafVersion)]
				if (documentMetadataForVersion) {
					def documentVersion = DateTimeFormatter.ofPattern('yyyyMMdd - dd MMMM yyyy', Locale.ENGLISH).format(documentMetadataForVersion.date as TemporalAccessor)
					def projectVersion = documentMetadataForVersion.version

					filter(ReplaceTokens, tokens: [
						documentVersion: documentVersion,
						projectVersion : projectVersion
					])
				}
			}
		}

		// Copiar todos los directorios de recursos directamente
		copy {
			from scriptsDir
			into "${srcDir.path}/scripts"
		}
		copy {
			from imagesDir
			into "${srcDir.path}/images"
		}
		copy {
			from stylesDir
			into "${srcDir.path}/styles"
		}

		// Generar la estructura del directorio de salida
		mkdir outputDir
	}
}

/**
 * Generar versiones HTML de la documentación de Thymeleaf.
 */
tasks.register('generateDocsHTML') {
	dependsOn 'copyResources'
	description "Genera documentos HTML a partir de los documentos de rebajas de Thymeleaf"

	doLast {
		docNames.each { docName ->
			def docType = docTypes.get(docName)

			if (conversions[docType].contains('html')) {
				println "Generando el documento HTML para ${docName} (${docType})..."

				def outputFile = file("${outputDir}/${docName}.html")
				file(outputFile.parent).mkdirs()
				exec {
					// Aquí se indica la ruta al ejecutable de pandoc, 'pandoc.exe', que dependerá de
					// la elección que hayas tomado en la instalación (N. del T.)
					commandLine = "pandoc"
					args = [
						"--write=html5",
						"--template=" + file("${templatesDir.path}/${docType}.html"),
						"--wrap=none",
						"--toc",
						"--toc-depth=4",
						"--section-divs",
						"--no-highlight",
						"--output=" + outputFile,
						"${srcDir.path}/${docName}.md"
					]
				}
			}
		}

		// Copiar los recursos necesarios para los documentos HTML
		copy {
			from srcDir
			into outputDir
			exclude '**/*.md'
		}
	}
}

/**
 * Genera libros electrónicos de la documentación de Thymeleaf.
 */
tasks.register('generateDocsEbook') {
	description "Genera libros electrónicos a partir de los documentos markdown de Thymeleaf"
	dependsOn 'copyResources'

	doLast {
		// Actualmente solo limitada a tutoriales.
		docNames.each { docName ->
			def docType = docTypes.get(docName)

			if (conversions[docType].contains('ebook')) {
				println "Generando el documento E-Book para ${docName} (${docType})..."

				def epubOutputFile = file("${outputDir}/${docName}.epub")
				def mobiOutputFile = file("${outputDir}/${docName}.mobi")
				file(epubOutputFile.parent).mkdirs()

				def inputFile = file("${srcDir.path}/${docName}.md")

				exec {
					// Necesitamos configurar el directorio de trabajo para que pandoc encuentre imágenes
					workingDir = file(inputFile.parent)

					// Aquí se indica la ruta al ejecutable de pandoc, 'pandoc.exe', que dependerá de
					// la elección que hayas tomado en la instalación (N. del T.)
					commandLine = "pandoc"
					args = [
						"--write=epub",
						"--template=" + file("${templatesDir.path}/${docType}.epub"),
						"--toc",
						"--toc-depth=4",
						"--section-divs",
						"--output=" + epubOutputFile,
						inputFile
					]
				}
				exec {
					commandLine = "ebook-convert"
					args = [
						epubOutputFile,
						mobiOutputFile
					]
				}
			}
		}
	}
}

/**
 * Usa una combinación de los plugins Gretty y ExecFork para iniciar un servidor
 * en un  proceso en segundo plano. Esto se debe a que Gretty bloquea el hilo
 * existente  hasta que el servidor se apaga por otros medios.
 */
tasks.register('startServer', ExecFork) {
	dependsOn 'war'

	commandLine = './gradlew'
	args = ['appStartWar']
	waitForOutput = 'Ejecute \'gradle appStop\' para parar el servidor'
}

/**
 * Genera versiones PDF de la documentación de Thymeleaf. Utiliza un servidor
 * Jetty para alojar los documentos HTML y wkhtmltopdf, que utiliza el servidor
 * para leer archivos mediante el protocolo http:// (de lo contrario, se aplica
 * la restricción del mismo origen, al igual que algunos errores de file:// en
 * Windows) y los guarda como documentos PDF.
 */
tasks.register('generateDocsPDF') {
	description "Genera documentos PDF a partir de los documentos HTML de Thymeleaf"
	dependsOn 'generateDocsHTML', 'startServer'

	doLast {
		// Genera los documentos PDF a partir de los documentos HTML modificados
		fileTree(outputDir) { include '*/**/*.html' as Closure }.each { docFile ->

			def folderBase = relativePath(file(outputDir))
			def docName = (relativePath(docFile).substring(folderBase.length() + 1) - ".html")
			def docType = docTypes.get(docName)

			if (conversions[docType].contains('pdf')) {
				println "Generando el documento PDF para  ${docName} (${docType})..."

				exec {
					// Aquí se indica la ruta al ejecutable 'whhtmltopdf.exe', que dependerá de
					// la elección que hayas tomado en la instalación (N. del T.)
					commandLine = 'wkhtmltopdf'
					args = [
						"--print-media-type",
						"--dpi", "300",
						"--javascript-delay", "1000",
						"--margin-bottom", "15",
						"--footer-spacing", "5",
						"--footer-font-size", "8",
						"--footer-font-name", "'Ubuntu'",
						"--footer-right", "Page [page] of [topage]",
						"--quiet",
						"http://localhost:8080/thymeleaf-docs/${docName}.html",
						file("${outputDir}/${docName}.pdf")
					]
				}
			}
		}

		exec {
			commandLine = './gradlew'
			args = ['appStop']
		}
	}
}

/**
 * Genera versiones HTML, de libro electrónico y PDF de la documentación de Thymeleaf.
 */
tasks.register('generateDocs') {
	dependsOn 'generateDocsHTML', 'generateDocsEbook', 'generateDocsPDF'

	// Solo una tarea de agregador
}

tasks.named('build') {
	dependsOn 'generateDocs'
}
